//+------------------------------------------------------------------+
//| Universal Scaling / Risk-Management Wrapper for MetaTrader 5    |
//| This Expert Advisor does not produce entry signals. Instead it   |
//| manages trades opened by another EA or manual strategy that      |
//| shares the same magic number (InMagicNumber).                    |
//|                                                                  |
//| Attach this EA on the same chart as your strategy. Set           |
//| InMagicNumber to match the managed EA's magic number. The EA     |
//| will enforce prop-style limits (daily drawdown, daily profit,    |
//| total drawdown) and apply scaling after losses.                  |
//|                                                                  |
//| The goal is to reach a net profit per cycle (TargetProfitMoney)  |
//| while respecting firm risk rules. When cycle profit is reached   |
//| or too many losses occur, the EA resets to the base risk.        |
//|                                                                  |
//| Author: Generated by ChatGPT (GPT-5.1-Codex-Max)                 |
//+------------------------------------------------------------------+
#property strict
#property copyright "OpenAI"
#property link      ""
#property version   "1.00"
#property description "Scaling and risk wrapper for prop-firm style management"

#include <Trade/Trade.mqh>

//--- Trend / filter inputs
input int      AdxPeriod              = 14;
input ENUM_TIMEFRAMES FirstTimeframe  = PERIOD_M15;
input ENUM_TIMEFRAMES SecondTimeframe = PERIOD_M30;
input ENUM_TIMEFRAMES ThirdTimeframe  = PERIOD_H1;

//--- Managed EA/strategy
input int      InMagicNumber          = 123456;

//--- Basic risk parameters
input double   BaseRiskMoney          = 500.0;    // risk per first trade in a cycle, account currency
input double   TargetProfitMoney      = 700.0;    // profit objective per cycle, account currency
input int      StopLossPips           = 1000;     // SL distance in pips

//--- Scaling configuration
enum ScalingMode { SCALING_LOTS, SCALING_DISTANCE, SCALING_BOTH };
input ScalingMode ScalingType         = SCALING_LOTS;
input double   LotMultiplierAfterLoss = 1.7;      // Lot multiplier after loss
input double   MaxDailyRiskPercent    = 4.0;      // Max daily risk % of starting balance
input int      MaxPositionsPerCycle   = 10;       // Maximum trades in one cycle
input int      TradesToChangeMode     = 10;       // Trades in cycle before scaling pauses
input int      LossesToResetCycle     = 10;       // Consecutive losses to reset
input bool     TradeWithTrend         = true;     // Only trade with detected trend
input bool     UseScalingManagement   = true;     // Enable scaling management
input bool     IgnoreHistoryOnRestart = true;     // Ignore history when restarting
input double   DistancePipsBetweenPositions = 200;// Distance in pips to add scale-in trades

//--- Money-management / prop rules
input double   MaxDailyLossMoney      = 0.0;      // Fixed daily loss; 0 disabled
input double   MaxTotalDrawdownPct    = 0.0;      // Total drawdown % from peak; 0 disabled
input double   DailyProfitTargetMoney = 0.0;      // Daily profit target; 0 disabled
input int      MaxOpenTrades          = 1;        // Max open trades controlled at once

//--- Behavior flags (internal tuning)
input bool     CloseTradesOnDailyStop = false;    // If true close trades when daily stop hit

//+------------------------------------------------------------------+
//| Global state                                                     |
//+------------------------------------------------------------------+
CTrade trade;

struct CycleState
  {
   double   cycleProfit;      // closed P/L in current cycle
   int      cycleTrades;      // trades counted in cycle
   int      consecutiveLosses;// consecutive losing trades
   double   currentRisk;      // current risk money for next trade
   double   lastLot;          // last lot used
   ENUM_POSITION_TYPE lastDirection;// last trade direction
   double   anchorPrice;      // price of first trade in cycle
   bool     active;           // whether a cycle is active
   CycleState() : cycleProfit(0.0),cycleTrades(0),consecutiveLosses(0),currentRisk(BaseRiskMoney),
                  lastLot(0.0),lastDirection(POSITION_TYPE_BUY),anchorPrice(0.0),active(false) {}
  };

CycleState cycle;

//--- Daily statistics
struct DailyStats
  {
   datetime startDay;
   double   startBalance;
   double   startEquity;
   double   maxEquity;
   double   minEquity;
   double   realisedPL;
   bool     tradingBlocked;
   bool     profitReached;
   DailyStats():startDay(0),startBalance(0),startEquity(0),maxEquity(0),minEquity(DBL_MAX),
                realisedPL(0),tradingBlocked(false),profitReached(false){}
  };

DailyStats daily;
double     peakBalance = 0.0;
bool       permanentlyHalted = false;

//+------------------------------------------------------------------+
//| Utility helpers                                                  |
//+------------------------------------------------------------------+
//--- pip size
inline double PipSize()
  {
   int digits = (int)SymbolInfoInteger(_Symbol,SYMBOL_DIGITS);
   if(digits==3 || digits==5)
      return(SymbolInfoDouble(_Symbol,SYMBOL_POINT)*10.0);
   return(SymbolInfoDouble(_Symbol,SYMBOL_POINT));
  }

//--- Normalize volume respecting symbol limits
double NormalizeVolume(double lots)
  {
   double min_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step    = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   lots = MathMax(lots,min_lot);
   lots = MathMin(lots,max_lot);
   double steps = MathFloor(lots/step + 0.0001);
   return(NormalizeDouble(steps*step,(int)SymbolInfoInteger(_Symbol,SYMBOL_VOLUME_DIGITS)));
  }

//--- Calculate lot size from risk money and SL distance
//    riskMoney: amount of account currency to risk
//    returns normalized lot size
double CalcLotFromRisk(double riskMoney)
  {
   double tick_size  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE_PROFIT);
   double pip        = PipSize();
   double price_move = StopLossPips * pip;
   if(tick_size<=0 || tick_value<=0 || price_move<=0)
      return(0);
   double loss_per_lot = (price_move / tick_size) * tick_value;
   if(loss_per_lot<=0)
      return(0);
   double lots = riskMoney / loss_per_lot;
   return NormalizeVolume(lots);
  }

//--- Determine trend direction using ADX on three TFs
//    returns -1 for downtrend, 1 for uptrend, 0 for undefined
int DetectTrend()
  {
   int tfs[3] = {(int)FirstTimeframe,(int)SecondTimeframe,(int)ThirdTimeframe};
   int bullish = 0, bearish = 0;
   for(int i=0;i<3;i++)
     {
      double plusDI = iADX(_Symbol,(ENUM_TIMEFRAMES)tfs[i],AdxPeriod,MODE_PLUSDI,0);
      double minusDI= iADX(_Symbol,(ENUM_TIMEFRAMES)tfs[i],AdxPeriod,MODE_MINUSDI,0);
      if(plusDI>minusDI) bullish++;
      else if(minusDI>plusDI) bearish++;
     }
   if(bullish>bearish) return 1;
   if(bearish>bullish) return -1;
   return 0;
  }

//--- Check if new trade direction aligns with trend
bool DirectionAllowed(ENUM_POSITION_TYPE dir)
  {
   if(!TradeWithTrend)
      return(true);
   int trend = DetectTrend();
   if(trend==0) return(true); // neutral
   if(dir==POSITION_TYPE_BUY && trend>0) return(true);
   if(dir==POSITION_TYPE_SELL && trend<0) return(true);
   return(false);
  }

//--- Check daily limits and total drawdown
bool CanTrade()
  {
   if(permanentlyHalted)
      return(false);

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity  = AccountInfoDouble(ACCOUNT_EQUITY);

   // total drawdown limit
   if(MaxTotalDrawdownPct>0.0)
     {
      if(peakBalance<=0.0)
         peakBalance = balance;
      if(balance>peakBalance)
         peakBalance = balance;
      double dd_pct = 100.0 * (peakBalance - equity) / peakBalance;
      if(dd_pct >= MaxTotalDrawdownPct)
        {
         Print("[RISK] Total drawdown limit exceeded: ",DoubleToString(dd_pct,2),"% >= ",MaxTotalDrawdownPct);
         CloseAllManagedPositions();
         permanentlyHalted = true;
         return(false);
        }
     }

   // daily checks
   UpdateDailyStats();
   if(daily.tradingBlocked || daily.profitReached)
      return(false);

   return(true);
  }

//--- Update daily statistics
void UpdateDailyStats()
  {
   datetime now = TimeCurrent();
   MqlDateTime t; TimeToStruct(now,t);
   datetime dayStart = StructToTime((MqlDateTime){t.year,t.mon,t.day,0,0,0});

   // New day detection
   if(daily.startDay!=dayStart)
     {
      daily.startDay     = dayStart;
      daily.startBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      daily.startEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
      daily.maxEquity    = daily.startEquity;
      daily.minEquity    = daily.startEquity;
      daily.realisedPL   = 0.0;
      daily.tradingBlocked=false;
      daily.profitReached=false;
      Print("[DAILY] Reset statistics for new day");
     }

   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double balance= AccountInfoDouble(ACCOUNT_BALANCE);
   if(equity>daily.maxEquity) daily.maxEquity = equity;
   if(equity<daily.minEquity) daily.minEquity = equity;

   double closedPL = 0.0;
   HistorySelect(daily.startDay, now);
   int deals = HistoryDealsTotal();
   for(int i=0;i<deals;i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if((string)HistoryDealGetString(ticket,DEAL_SYMBOL)!=_Symbol)
         continue;
      if((int)HistoryDealGetInteger(ticket,DEAL_MAGIC)!=InMagicNumber)
         continue;
      datetime dtime = (datetime)HistoryDealGetInteger(ticket,DEAL_TIME);
      if(dtime<daily.startDay) continue;
      ENUM_DEAL_ENTRY entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket,DEAL_ENTRY);
      if(entry==DEAL_ENTRY_IN || entry==DEAL_ENTRY_OUT)
         closedPL += HistoryDealGetDouble(ticket,DEAL_PROFIT) + HistoryDealGetDouble(ticket,DEAL_SWAP) + HistoryDealGetDouble(ticket,DEAL_COMMISSION);
     }
   daily.realisedPL = closedPL;

   double dailyLossPct = 0.0;
   if(daily.startBalance>0)
      dailyLossPct = 100.0 * (equity - daily.startBalance) / daily.startBalance;
   double dailyDrawdownFromStart = 100.0 * (daily.startEquity - equity) / daily.startEquity;

   if(!daily.tradingBlocked)
     {
      bool hitPercent = (MaxDailyRiskPercent>0.0 && dailyDrawdownFromStart >= MaxDailyRiskPercent);
      bool hitMoney   = (MaxDailyLossMoney>0.0   && (daily.startEquity - equity) >= MaxDailyLossMoney);
      if(hitPercent || hitMoney)
        {
         daily.tradingBlocked = true;
         Print("[DAILY] Trading blocked due to drawdown. Equity=",DoubleToString(equity,2)," Start=",DoubleToString(daily.startEquity,2));
         if(CloseTradesOnDailyStop)
            CloseAllManagedPositions();
        }
     }

   if(!daily.profitReached && DailyProfitTargetMoney>0.0)
     {
      if((equity - daily.startEquity) >= DailyProfitTargetMoney)
        {
         daily.profitReached = true;
         Print("[DAILY] Profit target reached. Trading paused until next day.");
        }
     }
  }

//--- Close all positions with managed magic and symbol
void CloseAllManagedPositions()
  {
   int total = PositionsTotal();
   for(int i=total-1;i>=0;i--)
     {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      if((int)PositionGetInteger(POSITION_MAGIC)!=InMagicNumber) continue;
      if((string)PositionGetString(POSITION_SYMBOL)!=_Symbol) continue;
      double volume = PositionGetDouble(POSITION_VOLUME);
      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      if(type==POSITION_TYPE_BUY)
         trade.PositionClose(ticket,volume,SymbolInfoDouble(_Symbol,SYMBOL_BID),10);
      else
         trade.PositionClose(ticket,volume,SymbolInfoDouble(_Symbol,SYMBOL_ASK),10);
     }
  }

//--- Count open trades managed by this EA
int ManagedOpenTrades()
  {
   int count=0;
   int total = PositionsTotal();
   for(int i=0;i<total;i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;
      if((int)PositionGetInteger(POSITION_MAGIC)!=InMagicNumber) continue;
      if((string)PositionGetString(POSITION_SYMBOL)!=_Symbol) continue;
      count++;
     }
   return(count);
  }

//--- Compute SL and TP prices
bool CalculateStops(ENUM_POSITION_TYPE type, double &sl, double &tp)
  {
   double pip = PipSize();
   double price = (type==POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol,SYMBOL_BID) : SymbolInfoDouble(_Symbol,SYMBOL_ASK));
   double distance = StopLossPips * pip;
   if(distance<=0) return(false);
   if(type==POSITION_TYPE_BUY)
     {
      sl = price - distance;
      tp = price + distance; // symmetrical TP
     }
   else
     {
      sl = price + distance;
      tp = price - distance;
     }
   return(true);
  }

//--- Determine next lot based on cycle and scaling type
double DetermineNextLot()
  {
   double risk = cycle.currentRisk;
   double lot  = CalcLotFromRisk(risk);
   if(cycle.cycleTrades>=TradesToChangeMode && TradesToChangeMode>0)
     {
      // Scaling paused; revert to base risk
      lot = CalcLotFromRisk(BaseRiskMoney);
     }
   return(lot);
  }

//--- Reset cycle to base settings
void ResetCycle()
  {
   cycle.cycleProfit = 0.0;
   cycle.cycleTrades = 0;
   cycle.consecutiveLosses = 0;
   cycle.currentRisk = BaseRiskMoney;
   cycle.lastLot = 0.0;
   cycle.anchorPrice = 0.0;
   cycle.active = false;
  }

//--- Rebuild cycle from history (simple approximation)
void RebuildCycleFromHistory()
  {
   if(IgnoreHistoryOnRestart)
     {
      ResetCycle();
      return;
     }

   datetime from = 0; // entire history
   datetime to   = TimeCurrent();
   HistorySelect(from,to);
   double pl = 0.0;
   int trades = 0;
   int losses = 0;
   int total = HistoryDealsTotal();
   for(int i=0;i<total;i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if((string)HistoryDealGetString(ticket,DEAL_SYMBOL)!=_Symbol) continue;
      if((int)HistoryDealGetInteger(ticket,DEAL_MAGIC)!=InMagicNumber) continue;
      ENUM_DEAL_ENTRY entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket,DEAL_ENTRY);
      if(entry!=DEAL_ENTRY_OUT) continue;
      double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT) + HistoryDealGetDouble(ticket,DEAL_SWAP) + HistoryDealGetDouble(ticket,DEAL_COMMISSION);
      pl += profit;
      trades++;
      if(profit<0) losses++;
     }

   cycle.cycleProfit = pl;
   cycle.cycleTrades = trades;
   cycle.consecutiveLosses = losses; // approximate
   cycle.currentRisk = BaseRiskMoney * MathPow(LotMultiplierAfterLoss, (double)losses);
   cycle.active = (trades>0);
   Print("[STATE] Rebuilt cycle from history. Trades=",trades," Profit=",DoubleToString(pl,2));
  }

//--- Apply SL/TP to managed positions
void ApplyStopsToPosition(ulong ticket)
  {
   if(!PositionSelectByTicket(ticket)) return;
   ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   double sl,tp;
   if(!CalculateStops(type,sl,tp)) return;
   trade.PositionModify(ticket,sl,tp);
  }

//--- Handle a newly opened trade to align with scaling state
void HandleNewEntry(const MqlTradeTransaction &trans)
  {
   ulong deal_ticket = trans.deal;
   double price  = trans.price;
   double volume = trans.volume;
   ENUM_DEAL_TYPE dealType = (ENUM_DEAL_TYPE)trans.deal_type;

   ENUM_POSITION_TYPE posType = (dealType==DEAL_TYPE_BUY || dealType==DEAL_TYPE_BUY_DEAL) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;

   // Check trend filter
   if(!DirectionAllowed(posType))
     {
      Print("[FILTER] Trade blocked due to trend filter. Closing new trade.");
      // Close the incoming trade immediately
      if(PositionSelect(_Symbol) && PositionGetInteger(POSITION_MAGIC)==InMagicNumber)
         trade.PositionClose(_Symbol);
      return;
     }

   double targetLot = DetermineNextLot();
   double additionalLot = 0.0;
   if(targetLot > volume)
      additionalLot = targetLot - volume;

   // Apply stops to the original position
   ulong posTicket = PositionGetTicketByDeal(deal_ticket);
   if(posTicket>0)
      ApplyStopsToPosition(posTicket);

   if(additionalLot>SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN)/2.0 && ManagedOpenTrades()<MaxPositionsPerCycle)
     {
      double sl,tp;
      if(!CalculateStops(posType,sl,tp)) return;
      bool ok=false;
      if(posType==POSITION_TYPE_BUY)
         ok = trade.Buy(additionalLot,_Symbol,0,sl,tp,"Scale-In");
      else
         ok = trade.Sell(additionalLot,_Symbol,0,sl,tp,"Scale-In");
      if(!ok)
         PrintFormat("[TRADE] Failed to scale-in. Error %d",GetLastError());
     }

   if(!cycle.active)
     {
      cycle.active = true;
      cycle.anchorPrice = price;
      cycle.lastDirection = posType;
     }

   cycle.lastLot = targetLot;
   cycle.cycleTrades++;
  }

//--- Handle closed trade to update cycle metrics
void HandleClosedDeal(const MqlTradeTransaction &trans)
  {
   double profit = trans.profit + trans.commission + trans.swap;
   cycle.cycleProfit += profit;

   if(profit < 0)
     {
      cycle.consecutiveLosses++;
      if(UseScalingManagement && (ScalingType==SCALING_LOTS || ScalingType==SCALING_BOTH))
         cycle.currentRisk *= LotMultiplierAfterLoss;
      if(cycle.consecutiveLosses >= LossesToResetCycle)
        {
         Print("[CYCLE] Loss threshold reached. Resetting cycle.");
         ResetCycle();
         return;
        }
     }
   else if(profit > 0)
     {
      cycle.consecutiveLosses = 0;
      // If profit target reached, close all and reset
      if(cycle.cycleProfit >= TargetProfitMoney)
        {
         Print("[CYCLE] Profit target reached. Closing open trades and resetting.");
         CloseAllManagedPositions();
         ResetCycle();
         return;
        }
      // On win without target, revert to base risk
      cycle.currentRisk = BaseRiskMoney;
     }
  }

//--- Open distance-based scale-in trade when price moves against anchor
void CheckDistanceScaling()
  {
   if(!UseScalingManagement)
      return;
   if(!(ScalingType==SCALING_DISTANCE || ScalingType==SCALING_BOTH))
      return;
   if(!cycle.active)
      return;
   if(cycle.cycleTrades>=MaxPositionsPerCycle)
      return;

   // verify there is an open position to anchor
   if(ManagedOpenTrades()<=0)
      return;

   double pip = PipSize();
   double distance = DistancePipsBetweenPositions * pip;
   if(distance<=0) return;

   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double price = (cycle.lastDirection==POSITION_TYPE_BUY ? bid : ask);
   double adverseMove = 0.0;
   if(cycle.lastDirection==POSITION_TYPE_BUY)
      adverseMove = cycle.anchorPrice - price;
   else
      adverseMove = price - cycle.anchorPrice;

   if(adverseMove >= distance)
     {
      double nextLot = DetermineNextLot();
      double sl,tp;
      if(!CalculateStops(cycle.lastDirection,sl,tp)) return;
      bool ok=false;
      if(cycle.lastDirection==POSITION_TYPE_BUY)
         ok = trade.Buy(nextLot,_Symbol,0,sl,tp,"Distance Scale");
      else
         ok = trade.Sell(nextLot,_Symbol,0,sl,tp,"Distance Scale");
      if(ok)
        {
         cycle.cycleTrades++;
         cycle.lastLot = nextLot;
         cycle.anchorPrice = price; // reset anchor for next distance step
        }
      else
        {
         PrintFormat("[TRADE] Distance scaling failed. Error %d",GetLastError());
        }
     }
  }

//--- Get position ticket from deal
ulong PositionGetTicketByDeal(ulong deal_id)
  {
   // In hedging accounts deal has position id, for netting the position equals symbol
   ulong position_id = HistoryDealGetInteger(deal_id,DEAL_POSITION_ID);
   if(position_id>0)
      return(position_id);
   // fallback for current positions
   if(PositionSelect(_Symbol))
      return((ulong)PositionGetInteger(POSITION_TICKET));
   return(0);
  }

//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
  {
   ResetCycle();
   RebuildCycleFromHistory();

   daily.startDay     = 0;
   daily.startBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   daily.startEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
   daily.maxEquity    = daily.startEquity;
   daily.minEquity    = daily.startEquity;
   peakBalance        = daily.startBalance;
   UpdateDailyStats();

   trade.SetExpertMagicNumber(InMagicNumber);
   Print("[INIT] Universal Scaling Manager loaded for symbol ",_Symbol," magic ",InMagicNumber);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   Print("[DEINIT] EA stopped. Reason ",reason);
  }

//+------------------------------------------------------------------+
//| Main tick handler                                                |
//+------------------------------------------------------------------+
void OnTick()
  {
   UpdateDailyStats();
   if(!CanTrade())
      return;

   // Enforce max open trades
   if(ManagedOpenTrades() >= MaxOpenTrades)
      return;

   // Distance-based scaling check
   CheckDistanceScaling();
  }

//+------------------------------------------------------------------+
//| Trade transaction handler                                        |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,const MqlTradeRequest& request,const MqlTradeResult& result)
  {
   if(trans.symbol!=_Symbol)
      return;

   // Filter by magic number
   if(trans.magic!=InMagicNumber)
      return;

   if(trans.type==TRADE_TRANSACTION_DEAL_ADD)
     {
      ENUM_DEAL_ENTRY entry = (ENUM_DEAL_ENTRY)trans.deal_entry;
      if(entry==DEAL_ENTRY_IN)
        {
         if(CanTrade())
            HandleNewEntry(trans);
         else
            Print("[TRADE] New entry blocked by risk rules.");
        }
      else if(entry==DEAL_ENTRY_OUT)
        {
         HandleClosedDeal(trans);
        }
     }
  }

//+------------------------------------------------------------------+
//| Notes and usage                                                  |
//|                                                                  |
//| 1. Attach this EA to the same chart as your primary strategy.    |
//| 2. Set InMagicNumber equal to the primary EA's magic number so   |
//|    the wrapper can monitor and scale its trades.                 |
//| 3. The EA does not create entry signals; it only responds to     |
//|    trades initiated elsewhere.                                   |
//| 4. Scaling: after a loss, risk increases by LotMultiplierAfterLoss
//|    (lot scaling). With SCALING_DISTANCE or SCALING_BOTH the EA   |
//|    can add new trades every DistancePipsBetweenPositions against |
//|    the position, aiming for net profit when the next win occurs. |
//| 5. Cycle: profit accumulates toward TargetProfitMoney; reaching  |
//|    it closes open trades and resets risk. LossesToResetCycle     |
//|    resets the cycle after many consecutive losses.               |
//| 6. Prop rules: MaxDailyRiskPercent/MaxDailyLossMoney block new   |
//|    entries for the day; MaxTotalDrawdownPct halts trading and    |
//|    optionally closes open trades.                                |
//| 7. Trend filter: if TradeWithTrend is true, trades must align    |
//|    with the ADX-derived multi-timeframe trend.                   |
//|                                                                  |
//| The logic is simplified to stay robust in backtests and live use.|
//| Always validate settings on a demo before live deployment.       |
//+------------------------------------------------------------------+
